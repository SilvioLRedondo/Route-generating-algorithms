import networkx as nx
import matplotlib.pyplot as plt



    
def GraphGen(n, m, k):
    """
    Crea un grafo que representa un almacén con dimensiones n x m y k ubicaciones de almacenamiento.

    Entradas:
        n (int): Número de hileras (ancho del almacén).
        m (int): Largo del almacén (número máximo de ubicaciones por hilera).
        k (int): Número total de ubicaciones de almacenamiento.

    Salida:
        G (networkx.Graph): Grafo generado.
    """
    if k > n * m:
        raise ValueError("El número de ubicaciones k no puede exceder el espacio total disponible n * m.")

    G = nx.Graph()

    # Nodos de entrada y salida
    G.add_node("q1")  
    G.add_node("q2")  

    # Distribuir ubicaciones en las hileras
    ubicaciones_por_hilera = [k // n] * n
    for i in range(k % n):
        ubicaciones_por_hilera[i] += 1

    # Crear las ubicaciones y conectarlas
    nodo_id = 1  
    hileras = []

    for i in range(n):
        hilera = []
        for j in range(ubicaciones_por_hilera[i]):
            nodo = f"u{nodo_id}"
            G.add_node(nodo)
            hilera.append(nodo)
            nodo_id += 1
        hileras.append(hilera)

    # Conectar nodos dentro de las hileras
    for hilera in hileras:
        for i in range(len(hilera) - 1):
            G.add_edge(hilera[i], hilera[i + 1])

    # Conexión extremos de las hileras 
    for i in range(len(hileras) - 1):
        G.add_edge(hileras[i][0], hileras[i + 1][0])  # Entrada de hilera i con entrada de hilera i+1
        G.add_edge(hileras[i][-1], hileras[i + 1][-1])  # Salida de hilera i con salida de hilera i+1

    # Conectar entrada almacén con los nodos de entrada de las hileras más cercanas
    for hilera in hileras:
        G.add_edge("q1", hilera[0])

    # Conectar salida almacén con los nodos de salida de las hileras más cercanas
    for hilera in hileras:
        G.add_edge("q2", hilera[-1])

    return G


----------------------------------------------------------------------
Del archivo funciones, creo que es la misma función que la anterior, no lo he revisado

def GraphGen(n, m, k):
    """
    Genera un grafo que representa un almacén con dimensiones n x m y k ubicaciones de almacenamiento.

    Parámetros:
        n (int): Número de hileras (ancho del almacén).
        m (int): Largo del almacén (número máximo de ubicaciones por hilera).
        k (int): Número total de ubicaciones de almacenamiento.

    Retorna:
        G (networkx.Graph): Grafo generado.
    """
    if k > n * m:
        raise ValueError("El número de ubicaciones k no puede exceder el espacio total disponible n * m.")

    # Crear el grafo
    G = nx.Graph()

    # Añadir nodos de entrada y salida
    G.add_node("q1")  # Nodo de entrada
    G.add_node("q2")  # Nodo de salida

    # Distribuir ubicaciones en las hileras
    ubicaciones_por_hilera = [k // n] * n
    for i in range(k % n):
        ubicaciones_por_hilera[i] += 1

    # Crear las ubicaciones y conectarlas
    nodo_id = 1  # Identificador único para las ubicaciones
    hileras = []

    for i in range(n):
        hilera = []
        for j in range(ubicaciones_por_hilera[i]):
            nodo = f"u{nodo_id}"
            G.add_node(nodo)
            hilera.append(nodo)
            nodo_id += 1
        hileras.append(hilera)

    # Conectar nodos dentro de las hileras
    for hilera in hileras:
        for i in range(len(hilera) - 1):
            G.add_edge(hilera[i], hilera[i + 1])

    # Conectar extremos de las hileras con sus homólogos
    for i in range(len(hileras) - 1):
        G.add_edge(hileras[i][0], hileras[i + 1][0])  # Entrada de hilera i con entrada de hilera i+1
        G.add_edge(hileras[i][-1], hileras[i + 1][-1])  # Salida de hilera i con salida de hilera i+1

    # Conectar q1 con los nodos de entrada de las hileras más cercanas
    for hilera in hileras:
        G.add_edge("q1", hilera[0])

    # Conectar q2 con los nodos de salida de las hileras más cercanas
    for hilera in hileras:
        G.add_edge("q2", hilera[-1])

    return G

-----------------------
main anterior:

for u, v, data in graph.edges(data=True):
        if 'weight' not in data:
            print(f"Missing weight: ({u}, {v})")

grafo = funTFG.GraphGen(5, 9, 45, 2)


    plt.figure(figsize=(10, 6))
    pos = nx.spring_layout(grafo)  # Posiciones de los nodos
    nx.draw(grafo, pos, with_labels=True, node_color="lightblue", node_size=500, font_size=10, font_weight="bold")
    plt.title("Representación del Grafo del Almacén")
    plt.show()
    
----------------------
Simulate robots aleatorio:

def simulate_robots(graph, robots, steps):
    """
    Simula el movimiento de los robots en el almacén.
    
    Cada robot se mueve aleatoriamente a un nodo vecino en cada paso.
    """
    plt.ion()  # Modo interactivo de matplotlib
    fig, ax = plt.subplots(figsize=(8, 6))
    pos = nx.spring_layout(graph, seed=42)

    for step in range(steps):
        ax.clear()
        nx.draw(graph, pos, with_labels=True, node_size=500, node_color="lightblue")

        # Mover los robots a un nodo vecino aleatorio
        for robot in robots:
            neighbors = list(graph.neighbors(robot["position"]))
            if neighbors:
                robot["position"] = random.choice(neighbors)

        # Dibujar robots
        robot_positions = [pos[robot["position"]] for robot in robots]
        ax.scatter(*zip(*robot_positions), color="red", s=750, label="Robots")

        plt.legend()
        plt.pause(0.5)  # Esperar medio segundo entre cada actualización

    plt.ioff()  # Desactivar modo interactivo
    plt.show()


------------------------------------
def simulate_robots(graph, robots, steps, method="A*"):
    """
    Simula el movimiento de los robots en el almacén con asignación de paquetes.
    """
    plt.ion()
    fig, ax = plt.subplots(figsize=(16, 12))
    pos = nx.get_node_attributes(graph, 'posicion')
    # pos = nx.spring_layout(graph, seed=42)

    for step in range(steps):
        ax.clear()
        nx.draw(graph, pos, with_labels=True, node_size=350, node_color="lightblue")

        # Generar paquetes en q1
        packages = ["q1"] * min(len(robots), random.randint(1, len(robots)))

        # Asignar paquetes a robots disponibles
        for robot in robots:
            if robot["target"] is None and packages:
                target = random.choice(list(graph.nodes))  # Ubicación aleatoria
                robot["target"] = target
                packages.pop()

        # Mover robots siguiendo A*
        for robot in robots:
            if robot["target"]:
                path = a_star_search(graph, robot["position"], robot["target"])
                if len(path) > 1:
                    robot["position"] = path[1]
                if robot["position"] == robot["target"]:
                    robot["target"] = None
        

        # Dibujar robots
        robot_positions = [pos[robot["position"]] for robot in robots]
        ax.scatter(*zip(*robot_positions), color="red", s=750, label="Robots")
        plt.legend()
        plt.pause(0.5)

    plt.ioff()
    plt.show()


-------------Desechado a día: 06/04/22025----------------


class Robot1:
    def __init__(self, id, position):
        """
        Constructor del robot.
        """
        self.id = id
        self.position = position  # Nodo discreto
        self.target = None
        self.distance = 0
        self.capacidad_carga = 0
        self.autonomia = 100
        self.disponible = True
        # Atributos para la simulación continua:
        self.continuous_position = None  # Posición continua (tuple)
        self.path = []  # Trayectoria (lista de nodos)
        self.current_edge_index = 0  # Índice del segmento actual
        self.progress_along_edge = 0.0  # Progreso (distancia recorrida en el segmento actual)

    def set_target(self, target):
        self.target = target

    def mover(self, nueva_posicion):
        self.position = nueva_posicion

    def __repr__(self):
        return f"Robot {self.id}"

class Nodo1:
    def __init__(self, nombre, posicion, peso=None, altura=None, estante=None):
        """
        Constructor del nodo.
        """
        self.nombre = nombre
        self.posicion = posicion
        self.peso = peso # Capacidad
        self.altura = altura
        self.estante = estante # Objeto que contenga

    def __hash__(self):
        return hash(self.nombre)
    
    def __eq__(self, other):
        return isinstance(other, Nodo) and self.nombre == other.nombre
    
    def __repr__(self):
        return self.nombre

    def __lt__(self, other):
        return self.nombre < other.nombre
    
    def get_posicion(self):
        return self.posicion

    def get_estante(self):
        return self.estante
---------


def simulate_robots_continuous(graph, robots, total_time, dt=0.1, speed=1):
    """
    Calcula la simulación en dominio continuo, almacenando un snapshot del estado (posición continua de cada robot)
    en cada intervalo dt.
    """
    simulation_data = []
    current_time = 0.0

    # Inicializar la posición continua de cada robot
    for robot in robots:
        robot.continuous_position = robot.position.posicion
        robot.path = []
        robot.current_edge_index = 0
        robot.progress_along_edge = 0.0

    while current_time < total_time:
        # Asignar destino a robots sin target
        for robot in robots:
            if robot.target is None:
                target = random.choice(list(graph.nodes()))
                robot.set_target(target)
                robot.path = a_star_search(graph, robot.position, robot.target)
                robot.current_edge_index = 0
                robot.progress_along_edge = 0.0

        # Actualizar la posición continua para cada robot
        for robot in robots:
            if robot.target and robot.path and robot.current_edge_index < len(robot.path) - 1:
                start_node = robot.path[robot.current_edge_index]
                end_node = robot.path[robot.current_edge_index + 1]
                start_pos = start_node.posicion
                end_pos = end_node.posicion
                dx = end_pos[0] - start_pos[0]
                dy = end_pos[1] - start_pos[1]
                segment_distance = math.sqrt(dx**2 + dy**2)
                distance_to_move = speed * dt
                remaining_distance = segment_distance - robot.progress_along_edge
                if distance_to_move < remaining_distance:
                    robot.progress_along_edge += distance_to_move
                    alpha = robot.progress_along_edge / segment_distance
                    new_x = start_pos[0] + alpha * dx
                    new_y = start_pos[1] + alpha * dy
                    robot.continuous_position = (new_x, new_y)
                else:
                    # Completa el segmento actual
                    robot.position = end_node  # Actualización discreta del nodo
                    robot.continuous_position = end_node.posicion
                    robot.current_edge_index += 1
                    robot.progress_along_edge = 0.0
                    if robot.current_edge_index >= len(robot.path) - 1:
                        robot.target = None
                        robot.path = []
                        robot.current_edge_index = 0
        # Guardar snapshot del estado actual
        snapshot = {robot.id: robot.continuous_position for robot in robots}
        # snapshot = [robot.continuous_position for robot in robots] #--------------------------------
        simulation_data.append(snapshot)
        current_time += dt

    return simulation_data


def playback_simulation(graph, simulation_data, dt=0.1):
    """
    Reproduce la simulación a partir de los snapshots calculados.
    """
    plt.ion()
    fig, ax = plt.subplots(figsize=(16, 12))
    pos = {node: node.posicion for node in graph.nodes()}
    
    for snapshot in simulation_data:
        ax.clear()
        nx.draw(graph, pos, with_labels=True, node_size=350, node_color="lightblue")
        robot_positions = list(snapshot.values())
        ax.scatter(*zip(*robot_positions), color="red", s=750, label="Robots")
        ax.legend(loc="upper left", fontsize=12, frameon=True)
        plt.pause(dt)
    
    plt.ioff()
    plt.show()
